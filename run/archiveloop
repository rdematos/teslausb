#!/bin/bash -eu
ARCHIVE_HOST_NAME="$1"

export LOG_FILE=/mutable/archiveloop.log

export CAM_MOUNT=/mnt/cam
export MUSIC_MOUNT=/mnt/music
export ARCHIVE_MOUNT=/mnt/archive
export CAM_SNAP_MOUNT=/mnt/cam_snap

function log () {
  echo "$( date )" >> "$LOG_FILE"
  echo "$1" >> "$LOG_FILE"
}

function fix_errors_in_mount_point () {
  local mount_point="$1"
  log "Running fsck on $mount_point..."
  /sbin/fsck "$mount_point" -- -a >> "$LOG_FILE" 2>&1 || echo ""
  log "Finished fsck on $mount_point."
}

function fix_errors_in_mounted_files () {
  fix_errors_in_mount_point "$CAM_MOUNT"
  fix_errors_in_mount_point "$MUSIC_MOUNT"
}

function archive_is_reachable () {
  local reachable=true

  /root/bin/archive-is-reachable.sh "$ARCHIVE_HOST_NAME" || reachable=false

  if [ "$reachable" = false ]
  then
    false
    return
  fi
  true
}

function connect_usb_drives_to_host() {
  log "Connecting usb to host..."
  modprobe g_mass_storage
  log "Connected usb to host."
}

function wait_for_archive_to_be_reachable () {
  log "Waiting for archive to be reachable..."
  while [ true ]
  do
    if archive_is_reachable
    then
      log "Archive is reachable."
      break
    fi
    if [ -e /tmp/archive_is_reachable ]
    then
      log "Simulating archive is reachable"
      rm /tmp/archive_is_reachable
      break
    fi
    sleep 1
  done
}

function retry () {
  local attempts=0
  while [ true ]
  do
    if eval "$@"
    then
      true
      return
    fi
    if [ "$attempts" -ge 10 ]
    then
      log "Attempts exhausted."
      false
      return
    fi
    log "Sleeping before retry..."
    /bin/sleep 1
    attempts=$((attempts + 1))
    log "Retrying..."
  done
  false
  return
}

function mount_mountpoint () {
  local mount_point="$1"
  log "Mounting $mount_point..."

  local mounted=true
  mount "$mount_point" >> "$LOG_FILE" 2>&1 || mounted=false
  if [ "$mounted" = true ]
  then
    log "Mounted $mount_point."
    true
    return
  else
    log "Failed to mount $mount_point."
    false
    return
  fi
}

function ensure_mountpoint_is_mounted () {
  local mount_point="$1"
  local mount_exists=true

  findmnt --mountpoint "$mount_point" > /dev/null || mount_exists=false

  if [ "$mount_exists" = true ]
  then
    log "$mount_point is already mounted."
  else
    mount_mountpoint "$mount_point"
  fi
}

function ensure_mountpoint_is_mounted_with_retry () {
  retry ensure_mountpoint_is_mounted "$1"
}

function fix_errors_in_cam_file () {
  fix_errors_in_mount_point "$CAM_MOUNT"
}

function ensure_cam_file_is_mounted () {
  log "Ensuring cam file is mounted..."
  ensure_mountpoint_is_mounted_with_retry "$CAM_MOUNT"
  log "Ensured cam file is mounted."
}

function ensure_cam_snap_file_is_mounted () {
  log "Ensuring cam snap file is mounted..."
  ensure_mountpoint_is_mounted_with_retry "$CAM_SNAP_MOUNT"
  log "Ensured cam snap file is mounted."
}

function ensure_music_file_is_mounted () {
  log "Ensuring music backing file is mounted..."
  ensure_mountpoint_is_mounted_with_retry "$MUSIC_MOUNT"
  log "Ensured cam drive is mounted."
}

function unmount_mount_point () {
  local mount_point="$1"
  log "Unmounting $mount_point..."
  umount "$mount_point" >> "$LOG_FILE" 2>&1
  log "Unmounted $mount_point."
}

function unmount_cam_file () {
  unmount_mount_point "$CAM_MOUNT"
}

function unmount_cam_snap_file () {
  unmount_mount_point "$CAM_SNAP_MOUNT"
}

function unmount_music_file () {
  unmount_mount_point "$MUSIC_MOUNT"
}

function fix_errors_in_music_file () {
  fix_errors_in_mount_point "$MUSIC_MOUNT"
}

function wait_for_archive_to_be_unreachable () {
  log "Waiting for archive to be unreachable..."
  while [ true ]
    do
      if ! retry archive_is_reachable
      then
        log "Archive is unreachable."
        break
      fi
      if [ -e /tmp/archive_is_unreachable ]
      then
        log "Simulating archive being unreachable."
        rm /tmp/archive_is_unreachable
        break
      fi
      sleep 1
  done
}

function mount_and_fix_errors_in_cam_file () {
  ensure_cam_file_is_mounted
  fix_errors_in_cam_file
  unmount_cam_file
}

function mount_and_fix_errors_in_music_file () {
  if [ -e "$MUSIC_MOUNT" ]
  then
    ensure_music_file_is_mounted
    fix_errors_in_music_file
    unmount_music_file
  fi
}

function mount_and_fix_errors_in_files () {
  mount_and_fix_errors_in_cam_file
  mount_and_fix_errors_in_music_file
}

function disconnect_usb_drives_from_host () {
  log "Disconnecting usb from host..."
  modprobe -r g_mass_storage
  log "Disconnected usb from host."
}

function archive_teslacam_clips () {
  log "Starting..."

  /root/bin/connect-archive.sh

  #RG# Since we fix the files on script start, and use snapshot, don't disconnect
  #disconnect_usb_drives_from_host

  #RG# take readonly snapshot to read from
  log "Taking read-only snapshot of /backingfiles to /backingfiles/snap.."
  btrfs subv snapshot -r /backingfiles /backingfiles/snap
  
  #RG# mount the snapshot instead
  #ensure_cam_file_is_mounted
  ensure_cam_snap_file_is_mounted

  #RG#
  # errors should be fixed on script start;
  # I don't think we should worry about scenarios where there's a constant
  # cycling between archive available and not 
  #fix_errors_in_cam_file

  /root/bin/archive-clips.sh

  /root/bin/disconnect-archive.sh

  #RG# Unmount the snapshot file instead
  #unmount_cam_file
  unmount_cam_snap_file
  log "Removing snapshot of /backingfiles..."
  btrfs subv delete -c /backingfiles/snap

  #connect_usb_drives_to_host
}

function archive_clips () {
  log "Archiving..."
  if archive_teslacam_clips
  then
    log "Finished archiving."
  else
    log "Archiving failed."
  fi
}

function truncate_log () {
  local log_length=$( wc -l "$LOG_FILE" | cut -d' ' -f 1 )
  if [ "$log_length" -gt 10000 ]
  then
    log "Truncating log..."
    local log_file2="${LOG_FILE}.2"
    tail -n 10000 "$LOG_FILE" > "${LOG_FILE}.2"
	mv "$log_file2" "$LOG_FILE"
  fi
}

export -f mount_mountpoint
export -f ensure_mountpoint_is_mounted
export -f retry
export -f ensure_mountpoint_is_mounted_with_retry
export -f log

log "Starting..."

#RG# always fix on boot/start, to take logic out of messing with it later
mount_and_fix_errors_in_files
connect_usb_drives_to_host

log "Removing any existing snapshot of /backingfiles..."
if [ -d /backingfiles/snap ]
then
  btrfs subv delete -c /backingfiles/snap
fi

if archive_is_reachable
then
  # archive_clips will fix errors in the cam file
  #RG# files should be fixed at boot
  #mount_and_fix_errors_in_music_file

  archive_clips

  wait_for_archive_to_be_unreachable
else
  #RG#
  #mount_and_fix_errors_in_files
  
  log "Archive isn't reachable, starting wait loop"
  
  #RG# never disconnected 
  #connect_usb_drives_to_host
fi

while [ true ]
do
  wait_for_archive_to_be_reachable

  archive_clips

  truncate_log
  
  wait_for_archive_to_be_unreachable
done
